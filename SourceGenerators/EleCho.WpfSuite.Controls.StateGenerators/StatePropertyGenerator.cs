using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EleCho.WpfSuite.Controls.StateGenerators
{
    [Generator]
    public class StatePropertyGenerator : IIncrementalGenerator
    {
        const string TagAttributeFullName = "EleCho.WpfSuite.Controls.SourceGeneration.GenerateStatePropertiesAttribute";
        const string BaseType = "DependencyObject";

        const string TypeStateManagerFullName = "global::EleCho.WpfSuite.Controls.States.StateManager";
        const string TypeDependencyPropertyFullName = "global::System.Windows.DependencyProperty";
        const string TypeBrushFullName = "global::System.Windows.Media.Brush";
        const string TypeThicknessFullName = "global::System.Windows.Thickness";
        const string TypeCornerRadiusFullName = "global::System.Windows.CornerRadius";

        [Flags]
        private enum StateFlags
        {
            None           = 0,
            Hover          = 1,
            Pressed        = 2,
            Checked        = 4,
            Selected       = 8,
            SelectedActive = 16,
            Disabled       = 32
        }

        private record struct GenerationInfo(INamedTypeSymbol NamedTypeSymbol, StateFlags StateFlags);

        private void AddStatePropertyDefinition(StringBuilder sb, string stateName, string propertyName, string typeName, int indent)
        {
            string indentText = new string(' ', indent);

            sb.AppendLine(
                $$"""
                {{indentText}}public {{typeName}}? {{stateName}}{{propertyName}} 
                {{indentText}}{
                {{indentText}}    get => ({{typeName}}?)GetValue({{stateName}}{{propertyName}}Property);
                {{indentText}}    set => SetValue({{stateName}}{{propertyName}}Property, value);
                {{indentText}}}
                {{indentText}}
                {{indentText}}public static readonly {{TypeDependencyPropertyFullName}} {{stateName}}{{propertyName}}Property
                {{indentText}}    = {{TypeStateManagerFullName}}.{{stateName}}{{propertyName}}Property.AddOwner(typeof({{typeName}}));
                {{indentText}}
                """);
        }

        private string GenerateForType(string name, string typeNamespace, StateFlags flags)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine(
                $$"""
                // <auto-generated/>

                namespace {{typeNamespace}}
                {
                    partial class {{name}}
                    {
                """);

            foreach (var flag in (StateFlags[])Enum.GetValues(typeof(StateFlags)))
            {
                if (flag == StateFlags.None ||
                    !flags.HasFlag(flag))
                {
                    continue;
                }

                var stateName = flag.ToString();

                AddStatePropertyDefinition(sb, stateName, "Background", TypeBrushFullName, 8);
                AddStatePropertyDefinition(sb, stateName, "Foreground", TypeBrushFullName, 8);
                AddStatePropertyDefinition(sb, stateName, "BorderBrush", TypeBrushFullName, 8);
                AddStatePropertyDefinition(sb, stateName, "Padding", TypeThicknessFullName, 8);
                AddStatePropertyDefinition(sb, stateName, "BorderThickness", TypeThicknessFullName, 8);
                AddStatePropertyDefinition(sb, stateName, "CornerRadius", TypeCornerRadiusFullName, 8);
            }

            sb.AppendLine(
                $$"""
                    }
                }
                """);

            return sb.ToString();
        }

        private static StateFlags GetStateFlagFromAttribute(AttributeSyntax syntaxNode)
        {
            var stateFlags = StateFlags.None;

            if (syntaxNode.ArgumentList is not null)
            {
                foreach (var argument in syntaxNode.ArgumentList.Arguments)
                {
                    if (argument.Expression is not MemberAccessExpressionSyntax memberAccessExpression)
                    {
                        continue;
                    }

                    var name = memberAccessExpression.Name.Identifier.ValueText;
                    if (Enum.TryParse<StateFlags>(name, out var stateFlag))
                    {
                        stateFlags |= stateFlag;
                    }
                }
            }

            return stateFlags;
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var generationInfos = context.SyntaxProvider.ForAttributeWithMetadataName(
                TagAttributeFullName,
                static (node, _) => node is ClassDeclarationSyntax,
                static (context, token) =>
                {
                    INamedTypeSymbol typeSymbol = (INamedTypeSymbol)context.TargetSymbol;

                    var flags = StateFlags.None;
                    var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;

                    foreach (var attributeList in classDeclaration.AttributeLists)
                    {
                        foreach (var attribute in attributeList.ChildNodes())
                        {
                            var flag = GetStateFlagFromAttribute((AttributeSyntax)attribute);

                            flags |= flag;
                        }
                    }

                    return new GenerationInfo(typeSymbol, flags);
                });

            context.RegisterSourceOutput(generationInfos, (context, generationInfo) =>
            {
                var typeName = generationInfo.NamedTypeSymbol.Name;
                var typeNamespace = generationInfo.NamedTypeSymbol.ContainingNamespace.ToString();

                context.AddSource($"{typeNamespace}.{typeName}.StateProperties.g.cs", GenerateForType(typeName, typeNamespace, generationInfo.StateFlags));
            });
        }
    }
}
